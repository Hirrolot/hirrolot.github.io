<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Hirrolot's Blog">
  <title>Announcing Beatrice: A finally tagless, dependently typed, self-aware programming language</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&amp;display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<a class="header-link" href="#"><h1 class="title">Announcing Beatrice: A finally tagless, dependently
typed, self-aware programming language</h1></a>
<p class="author">Hirrolot's Blog</p>
<p class="date">Apr 22, 2024</p>
</header>
<div class="introduction">
<p>Today I am pleased to announce <a href="https://github.com/beatrice-lang/beatrice">Beatrice</a>, which is
a <em>finally tagless</em>, <em>dependently typed</em>,
<em>self-aware</em> functional programming language that I have been
working on for quite a while. In this short blog post, I will
demonstrate its most prominent features and contrast them to those of
mainstream programming languages.</p>
</div><nav id="TOC" role="doc-toc" style="display: block;"><h4 class="toc-title">Table of Contents</h4>
<ul>
<li><a href="#dependent-types">Dependent types</a></li>
<li><a href="#tagless-final">Tagless-final</a></li>
<li><a href="#typed-tagless-metaprogramming">Typed tagless
metaprogramming</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
</ul>
</nav>










































<div class="post-body"><a class="header-link" href="#dependent-types"><h2 id="dependent-types">Dependent types</h2></a><p>In Beatrice, types can <a href="https://en.wikipedia.org/wiki/Dependent_type">depend on
values</a>. This allows many real-world patterns to be expressed as
ordinary functions. Consider the <code>String.format</code> function
from the standard library, which can be used as follows:</p><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a>import { "std/src/String.bea" }</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>// "Be-a-trice"</span>
<span id="cb1-4"><a href="#cb1-4"></a>export</span>
<span id="cb1-5"><a href="#cb1-5"></a>main: string =</span>
<span id="cb1-6"><a href="#cb1-6"></a>    let speak = String.format(via="%s-%s-%s");</span>
<span id="cb1-7"><a href="#cb1-7"></a>    speak(x="Be", x="a", x="trice");</span></code></pre></div><p>The type of <code>speak</code> is
<code>(x: string, x: string, x: string) -&gt; string</code>. If we were
to call <code>String.format</code> with <code>via="%s %b %i32"</code>,
the type would be
<code>(x: string, x: boolean, x: i32) -&gt; string</code>. Thanks to
first-class functions, we can even store the application of
<code>String.format</code> to <code>via</code> as an ordinary
let-binding.</p><p>Most often, string formatting is expressed either as an unsafe
variadic function or macro. In some situations, extra compiler magic is
required. In Beatrice, string formatting is just an ordinary function
whose type can be statically inferred and checked. For example, if we
attempt to pass a boolean instead of a string:</p><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb2-1"><a href="#cb2-1"></a>import { "std/src/String.bea" }</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a>// "Be-a-trice"</span>
<span id="cb2-4"><a href="#cb2-4"></a>export</span>
<span id="cb2-5"><a href="#cb2-5"></a>main: string =</span>
<span id="cb2-6"><a href="#cb2-6"></a>    let speak = String.format(via="%s-%s-%s");</span>
<span id="cb2-7"><a href="#cb2-7"></a>    speak(x=true, x="a", x="trice");</span></code></pre></div><p>we will receive the following compilation error:</p><div class="sourceCode" id="cb3"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb3-1"><a href="#cb3-1"></a>error: src/Main.bea:7:13: Expected type `string`, got `boolean`:</span>
<span id="cb3-2"><a href="#cb3-2"></a>7 |     speak(x=true, x="a", x="trice");</span>
<span id="cb3-3"><a href="#cb3-3"></a>                ^^^^</span></code></pre></div><p>This example manifests the ability of our type system to embed
domain-specific languages with custom syntax in a typed manner. I invite
you to study <a href="https://github.com/beatrice-lang/beatrice/blob/master/imports/std/src/String/Format.bea">the
implementation</a> of <code>String.format</code> to see how it is
done.</p><a class="header-link" href="#tagless-final"><h2 id="tagless-final">Tagless-final</h2></a><p>In Beatrice, <a href="https://okmij.org/ftp/tagless-final/">functions
are composed directly</a>, and if there are several interrelated
functions, they are stored in a record. This style is called
<em>tagless-final</em>.</p><p>Consider our encoding of a functional list:</p><div class="sourceCode" id="cb4"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb4-1"><a href="#cb4-1"></a>List(a: type) -&gt; type = {</span>
<span id="cb4-2"><a href="#cb4-2"></a>    repr: type,</span>
<span id="cb4-3"><a href="#cb4-3"></a>    Nil: repr,</span>
<span id="cb4-4"><a href="#cb4-4"></a>    Cons: (x: a, xs: repr) -&gt; repr</span>
<span id="cb4-5"><a href="#cb4-5"></a>};</span></code></pre></div><p>Common operations such as <code>count</code>, <code>filter</code>,
and <code>map</code> can be defined as follows:</p><div class="sourceCode" id="cb5"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb5-1"><a href="#cb5-1"></a>count(a: type) -&gt; List(a) = { repr=u64, Nil=0, Cons(_x, xs) = (1 + xs) };</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>filter(a: type, f: (x: a) -&gt; boolean, cont: List(a)) -&gt; List(a) = {</span>
<span id="cb5-4"><a href="#cb5-4"></a>    repr=cont.repr,</span>
<span id="cb5-5"><a href="#cb5-5"></a>    Nil=cont.Nil,</span>
<span id="cb5-6"><a href="#cb5-6"></a>    Cons(x, xs) = if { f(x) -&gt; cont.Cons(x, xs); _ -&gt; xs }</span>
<span id="cb5-7"><a href="#cb5-7"></a>};</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>map(a: type, b: type, f: (x: a) -&gt; b, cont: List(a=b)) -&gt; List(a) = {</span>
<span id="cb5-10"><a href="#cb5-10"></a>    repr=cont.repr,</span>
<span id="cb5-11"><a href="#cb5-11"></a>    Nil=cont.Nil,</span>
<span id="cb5-12"><a href="#cb5-12"></a>    Cons(x, xs) = cont.Cons(x=f(x), xs)</span>
<span id="cb5-13"><a href="#cb5-13"></a>};</span></code></pre></div><p>and used as follows:</p><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb6-1"><a href="#cb6-1"></a>// 3u64</span>
<span id="cb6-2"><a href="#cb6-2"></a>export</span>
<span id="cb6-3"><a href="#cb6-3"></a>main: u64 =</span>
<span id="cb6-4"><a href="#cb6-4"></a>    let pipeline =</span>
<span id="cb6-5"><a href="#cb6-5"></a>        (map(a=string, b=string, f(s) = ("x" ++ s ++ "x"))</span>
<span id="cb6-6"><a href="#cb6-6"></a>         -&gt; filter(a=string, f(s) = (length of s &gt;= 5))</span>
<span id="cb6-7"><a href="#cb6-7"></a>         -&gt; count(a=string));</span>
<span id="cb6-8"><a href="#cb6-8"></a>    [ "a", "ab", "abc", "abcd", "abcde" ] with pipeline;</span></code></pre></div><p>This mechanism allows us to throw out algebraic data types from the
language. In return, we obtain 1) a simpler core language, 2) less
interpretive overhead, 3) a more compositional style of programming, 4)
<a href="https://github.com/beatrice-lang/beatrice/blob/master/examples/expression-problem/src/Main.bea">extensibility
in both axes</a>, and 5) apparentness of termination of algorithms. We
pay the price by losing the ability to do nested pattern matching in a
direct way; however, it can still be done by <a href="https://okmij.org/ftp/tagless-final/course/lecture.pdf">explicating
the context</a>, which is more apparent in terms of termination.</p><p>Interestingly, the tagless-final style can be used to model not only
data types but also algebraic effects. Consider the state effect:</p><div class="sourceCode" id="cb7"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>State(s: type, a: type) -&gt; type = {</span>
<span id="cb7-2"><a href="#cb7-2"></a>    repr: type,</span>
<span id="cb7-3"><a href="#cb7-3"></a>    return: (self: a) -&gt; repr,</span>
<span id="cb7-4"><a href="#cb7-4"></a>    get: (cont: (state: s) -&gt; repr) -&gt; repr,</span>
<span id="cb7-5"><a href="#cb7-5"></a>    set: (self: s, cont: (force: unit) -&gt; repr) -&gt; repr</span>
<span id="cb7-6"><a href="#cb7-6"></a>};</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a>new(s: type, a: type) -&gt; State(s, a) = {</span>
<span id="cb7-9"><a href="#cb7-9"></a>    repr=(self: s) -&gt; a,</span>
<span id="cb7-10"><a href="#cb7-10"></a>    return(self, _state) = self,</span>
<span id="cb7-11"><a href="#cb7-11"></a>    get(cont, self) = (cont(state=self)) @ self,</span>
<span id="cb7-12"><a href="#cb7-12"></a>    set(self, cont, _state) = (cont(force=_)) @ self</span>
<span id="cb7-13"><a href="#cb7-13"></a>};</span></code></pre></div><p>using a sort of do notation, we can manipulate <code>State</code> as
follows:</p><div class="sourceCode" id="cb8"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb8-1"><a href="#cb8-1"></a>test(cont: State(s=i32, a=string)) -&gt; cont.repr =</span>
<span id="cb8-2"><a href="#cb8-2"></a>    do x &lt;- cont.get;</span>
<span id="cb8-3"><a href="#cb8-3"></a>    do cont.set @ (x + 7);</span>
<span id="cb8-4"><a href="#cb8-4"></a>    do x &lt;- cont.get;</span>
<span id="cb8-5"><a href="#cb8-5"></a>    cont.return @ string of x;</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>// "12"</span>
<span id="cb8-8"><a href="#cb8-8"></a>export</span>
<span id="cb8-9"><a href="#cb8-9"></a>main: string =</span>
<span id="cb8-10"><a href="#cb8-10"></a>    let state = new(s=i32, a=string);</span>
<span id="cb8-11"><a href="#cb8-11"></a>    ((test -&gt; state)) @ 5;</span></code></pre></div><a class="header-link" href="#typed-tagless-metaprogramming"><h2 id="typed-tagless-metaprogramming">Typed tagless
metaprogramming</h2></a><p>Beatrice can represent its typed abstract syntax <a href="https://github.com/beatrice-lang/beatrice/blob/master/imports/std/src/Metacode.bea">within
itself</a>. This allows us to manipulate Beatrice programs within
Beatrice.</p><p>For example, if we are to invert every control flow condition in a
program:</p><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb9-1"><a href="#cb9-1"></a>import { "std/src/Metacode.bea", "std/src/Metasystem/Demetacoder.bea" }</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>pass: Metacode.T = Demetacoder.run;</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>invertConditions: Metacode.T = {</span>
<span id="cb9-6"><a href="#cb9-6"></a>    repr(self) = self,</span>
<span id="cb9-7"><a href="#cb9-7"></a>    reflect=pass.reflect,</span>
<span id="cb9-8"><a href="#cb9-8"></a>    Const=pass.Const,</span>
<span id="cb9-9"><a href="#cb9-9"></a>    FreeVar=pass.FreeVar,</span>
<span id="cb9-10"><a href="#cb9-10"></a>    Fn=pass.Fn,</span>
<span id="cb9-11"><a href="#cb9-11"></a>    Pair=pass.Pair,</span>
<span id="cb9-12"><a href="#cb9-12"></a>    FnTy=pass.FnTy,</span>
<span id="cb9-13"><a href="#cb9-13"></a>    PairTy=pass.PairTy,</span>
<span id="cb9-14"><a href="#cb9-14"></a>    Appl=pass.Appl,</span>
<span id="cb9-15"><a href="#cb9-15"></a>    SelectFirst=pass.SelectFirst,</span>
<span id="cb9-16"><a href="#cb9-16"></a>    Behead=pass.Behead,</span>
<span id="cb9-17"><a href="#cb9-17"></a>    Let=pass.Let,</span>
<span id="cb9-18"><a href="#cb9-18"></a>    IfThenElse(_a, cond, m, n) = if { !cond -&gt; m; _ -&gt; n },</span>
<span id="cb9-19"><a href="#cb9-19"></a>    BooleanOp=pass.BooleanOp,</span>
<span id="cb9-20"><a href="#cb9-20"></a>    IntOp1=pass.IntOp1,</span>
<span id="cb9-21"><a href="#cb9-21"></a>    IntOp2=pass.IntOp2,</span>
<span id="cb9-22"><a href="#cb9-22"></a>    StringOp1=pass.StringOp1,</span>
<span id="cb9-23"><a href="#cb9-23"></a>    StringOp2=pass.StringOp2,</span>
<span id="cb9-24"><a href="#cb9-24"></a>    Break=pass.Break,</span>
<span id="cb9-25"><a href="#cb9-25"></a>    Continue=pass.Continue,</span>
<span id="cb9-26"><a href="#cb9-26"></a>    ControlTy=pass.ControlTy,</span>
<span id="cb9-27"><a href="#cb9-27"></a>    Loop=pass.Loop,</span>
<span id="cb9-28"><a href="#cb9-28"></a>    TypeOf=pass.TypeOf,</span>
<span id="cb9-29"><a href="#cb9-29"></a>    Delay=pass.Delay,</span>
<span id="cb9-30"><a href="#cb9-30"></a>    Panic=pass.Panic,</span>
<span id="cb9-31"><a href="#cb9-31"></a>    Precompute=pass.Precompute,</span>
<span id="cb9-32"><a href="#cb9-32"></a>    Transfix=pass.Transfix</span>
<span id="cb9-33"><a href="#cb9-33"></a>};</span>
<span id="cb9-34"><a href="#cb9-34"></a></span>
<span id="cb9-35"><a href="#cb9-35"></a>// "Success"</span>
<span id="cb9-36"><a href="#cb9-36"></a>export</span>
<span id="cb9-37"><a href="#cb9-37"></a>main: string = metacode {</span>
<span id="cb9-38"><a href="#cb9-38"></a>    let x: i32 = 5;</span>
<span id="cb9-39"><a href="#cb9-39"></a>    if {</span>
<span id="cb9-40"><a href="#cb9-40"></a>        (x != 5) -&gt; if { ((x * 2) = 30) -&gt; "Success"; _ -&gt; "Failure" };</span>
<span id="cb9-41"><a href="#cb9-41"></a>        _ -&gt; "Failure"</span>
<span id="cb9-42"><a href="#cb9-42"></a>    }</span>
<span id="cb9-43"><a href="#cb9-43"></a>} with invertConditions;</span></code></pre></div><p><code>Demetacoder.run</code> is a simple <a href="https://github.com/beatrice-lang/beatrice/blob/master/imports/std/src/Metasystem/Demetacoder.bea">metacircular
evaluator</a> of Beatrice. By reusing it everywhere except for
<code>IfThenElse</code>, we were able to compositionally process each
language form in the input program. The result of this processing is
guaranteed to be a syntactically correct, well-scoped, and well-typed
Beatrice program.</p><p>A similar feature can be found in almost every modern general-purpose
programming language. However, the crucial difference is that our
approach allows us to catch metaprogramming bugs at the time of
definition of the program transformer, not its usage. For example, if we
write the following:</p><div class="sourceCode" id="cb10"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb10-1"><a href="#cb10-1"></a>    IfThenElse(_a, cond, m, n) = if { !cond -&gt; "oops"; _ -&gt; n },</span></code></pre></div><p>we will receive the following compilation error:</p><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb11-1"><a href="#cb11-1"></a>error: src/Main.bea:22:53: Expected type `_a`, got `string`:</span>
<span id="cb11-2"><a href="#cb11-2"></a>22 |     IfThenElse(_a, cond, m, n) = if { !cond -&gt; "oops"; _ -&gt; n },</span></code></pre></div><p>Our treatment of metaprogramming is partly inspired by a cybernetical
programming language called <a href="http://www.botik.ru/~scp/book/">Refal-5</a>. Manipulating
program’s code (which we call <em>metacode</em>) can be seen as an
example of <a href="http://pespmc1.vub.ac.be/MST.html"><em>metasystem
transition</em></a>.</p><a class="header-link" href="#final-words"><h2 id="final-words">Final words</h2></a><p>There are many other interesting examples of Beatrice, such as <a href="https://github.com/beatrice-lang/beatrice/blob/master/examples/church-factorial/src/Main.bea">ad-hoc
polymorphism</a>, <a href="https://github.com/beatrice-lang/beatrice/blob/master/examples/futamura-1/src/Main.bea">partial
computation</a>, and <a href="https://github.com/beatrice-lang/beatrice/blob/master/examples/stlc/src/Main.bea">embedding
typed higher-order calculi</a>. <a href="https://github.com/beatrice-lang/beatrice/blob/master/docs/taste.md">This
page</a> will give you a more comprehensive overview of the
language.</p><p>In designing Beatrice, I attempted to combine every significant
aspect of the language with symbolic execution (that can work in the
presence of unknown values). Thus, 1) Beatrice’s abstract syntax can be
manipulated by <em>executing</em> the transformer’s methods, 2)
Beatrice’s terms can be evaluated during type checking, and 3) partial
computation can be used to obtain more efficient target programs. The
full power, as well as consequences, of this design approach are yet to
be explored.</p><p>For a diligent reader, I have prepared a comprehensive <a href="https://github.com/beatrice-lang/beatrice/blob/master/docs/design.md">design
document</a> that explains and discusses nearly every design choice
behind Beatrice. A mathematically inclined reader is invited to study
the <a href="https://github.com/beatrice-lang/beatrice/blob/master/spec/Beatrice_the_Language.pdf">formal
semantics</a> of Beatrice.</p><a class="header-link" href="#acknowledgments"><h2 id="acknowledgments">Acknowledgments</h2></a><p>I would like to thank <a href="https://github.com/cppenjoy">@cppenjoy</a> for testing the
compiler, helping to write the <code>System</code> standard library
module, and provoking useful discussions regarding the language.
Beatrice is built on prior art of many researchers and programming
language enthusiasts, including Oleg Kiselyov, Thierry Coquand, Valentin
Turchin, Lennart Augustsson, András Kovács, Edwin Brady, and many
others.</p><script src="https://giscus.app/client.js" data-repo="Hirrolot/hirrolot.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ4MzI2NDA=" data-category="Announcements" data-category-id="DIC_kwDOEsP3AM4CSEqw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="https://hirrolot.github.io/giscus-theme.css" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script></div></body></html>