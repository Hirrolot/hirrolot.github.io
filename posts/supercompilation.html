<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="hirrolot's Blog">
  <title>Supercompilation: The Ultimate Compiler Optimization</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&amp;display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<a class="header-link" href="#"><h1 class="title">Supercompilation: The Ultimate Compiler
Optimization</h1></a>
<p class="author">hirrolot's Blog</p>
<p class="date">Aug 7, 2024</p>
</header>
<div class="introduction">
<p>A typical optimizing compiler works in passes, each being a set of
rewriting rules that transform some intermediate representation in a
semantics-preserving way. In modern compilers, there can be a numerous
amount of passes, which raises concerns such as 1) what is the correct
order of application, 2) when to stop applying passes, 3) how to balance
the trade-off between compilation times and program performance, 4) what
a user interface for controlling passes should look like, and etc. This
approach views the input program as a <em>self-sufficient</em> set of
instructions that need to be <em>modified</em> into a more efficient
form, while maintaining correctness and self-sufficiency; this type of
code optimizer is nothing but a submissive machine that blindly applies
the rules that it was given by us, knowledgeable compiler
developers.</p>
<p>In the early 1970s, <a href="https://en.wikipedia.org/wiki/Valentin_Turchin">V. F. Turchin</a>,
a prominent physicist and computer scientist from the Soviet Union,
started to experiment on a methodologically different type of program
transformation – <em>supercompilation</em> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
Instead of sequential rewriting of the input program, supercompilation
starts with an <em>empty</em> program and progressively
<em>synthesizes</em> a self-sufficient output program by the means of
symbolic execution, with run-time values regarded as unknowns. In doing
so, supercompilation views the program under construction as graph of
possible states of execution, which can be then turned into a program in
the same (or different) source language.</p>
<p>After Turchin was forced to leave the Soviet Union due to his <a href="https://en.wikipedia.org/wiki/Soviet_dissidents">dissident
activities</a> in 1977, the idea of supercompilation started to
proliferate in the rest of the world. Sørensen et al.&nbsp;proved <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> supercompilation to subsume both
deforestation <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> and partial evaluation <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, making it one of the most
intelligent program transformations known to date; people started to
experiment with supercompilation <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> on
simpler functional languages than Refal, the original language Turchin
used in his works; supercompilation was adapted for call-by-need <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> and call-by-value <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> reduction strategies, and was
further refined to transform higher-order languages such as Haskell <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>. With the rampant increase of
computing powers, supercompilation started to be viewed as a viable
alternative to traditional compiler optimizations: given any
(small-step) operational semantics, we can derive the supercompilation
algorithm for it.</p>
<p>This essay is an attempt to explain the essentials of
supercompilation on <a href="https://github.com/mazeppa-dev/mazeppa">Mazeppa</a>, a modern
supercompiler for call-by-value functional languages. With no prior
knowledge required, you will learn how supercompilation performs
symbolic execution, how it detects possible non-termination, and how it
finally converts the process graph to a textual representation. Having
this done, we will go through a few interesting examples, such as
evaluating Turing-complete lambda calculus and synthesizing an efficient
substring search algorithm (<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a>).
In the conclusion, we will discuss various extensions to
supercompilation – including those that give asymptotic speedups of
functional programs in a fully automated manner.</p>
<p>You are invited to tweak and play with the samples below: all of them
can be reproduced by <a href="https://github.com/mazeppa-dev/mazeppa/blob/master/README.md#installation">running
Mazeppa on your computer</a>.</p>
</div><nav id="TOC" role="doc-toc" style="display: block;"><h4 class="toc-title">Table of Contents</h4>
<ul>
<li><a href="#references">References</a></li>
</ul>
</nav>






<div class="post-body"><a class="header-link" href="#references"><h2 id="references">References</h2></a><section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Valentin F. Turchin. 1986. The
concept of a supercompiler. ACM Trans. Program. Lang. Syst. 8, 3 (July
1986), 292–325. https://doi.org/10.1145/5956.5957<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Morten Heine Sørensen, Robert Glück,
and Neil D. Jones. 1994. Towards Unifying Partial Evaluation,
Deforestation, Supercompilation, and GPC. In Proceedings of the 5th
European Symposium on Programming: Programming Languages and Systems
(ESOP ’94). Springer-Verlag, Berlin, Heidelberg, 485–500.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Philip Wadler. 1988. Deforestation:
transforming programs to eliminate trees. Theor. Comput. Sci. 73, 2
(June 22, 1990), 231–248. https://doi.org/10.1016/0304-3975(90)90147-A<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Futamura, Y. (1983). Partial
computation of programs. In: Goto, E., Furukawa, K., Nakajima, R.,
Nakata, I., Yonezawa, A. (eds) RIMS Symposia on Software Science and
Engineering. Lecture Notes in Computer Science, vol 147. Springer,
Berlin, Heidelberg. https://doi.org/10.1007/3-540-11980-9_13<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Glück, R., Klimov, A.V. (1993).
Occam’s razor in metacomputation: the notion of a perfect process tree.
In: Cousot, P., Falaschi, M., Filé, G., Rauzy, A. (eds) Static Analysis.
WSA 1993. Lecture Notes in Computer Science, vol 724. Springer, Berlin,
Heidelberg. https://doi.org/10.1007/3-540-57264-3_34<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Sørensen, Morten Heine. Turchin’s
supercompiler revisited: An operational theory of positive information
propagation. Diss. Datalogisk Institut, Københavns Universitet, 1994.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Sørensen, Morten Heine, and Robert
Glück. “An Algorithm of Generalization in Positive Supercompilation.”
ILPS. Vol. 95. 1995.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Robert Glück and Morten Heine
Sørensen. 1996. A Roadmap to Metacomputation by Supercompilation. In
Selected Papers from the International Seminar on Partial Evaluation.
Springer-Verlag, Berlin, Heidelberg, 137–160.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Sørensen MH, Glück R, Jones ND. A
positive supercompiler. Journal of Functional Programming.
1996;6(6):811-838. doi:10.1017/S0956796800002008<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Bolingbroke, Maximilian C.
Call-by-need supercompilation. No.&nbsp;UCAM-CL-TR-835. University of
Cambridge, Computer Laboratory, 2013.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>Peter A. Jonsson and Johan
Nordlander. 2009. Positive supercompilation for a higher order
call-by-value language. SIGPLAN Not. 44, 1 (January 2009), 277–288.
https://doi.org/10.1145/1594834.1480916<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Jonsson, Peter &amp; Nordlander,
Johan. (2010). Strengthening supercompilation for call-by-value
languages.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>Maximilian Bolingbroke and Simon
Peyton Jones. 2010. Supercompilation by evaluation. In Proceedings of
the third ACM Haskell symposium on Haskell (Haskell ’10). Association
for Computing Machinery, New York, NY, USA, 135–146.
https://doi.org/10.1145/1863523.1863540<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><script src="https://giscus.app/client.js" data-repo="hirrolot/hirrolot.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ4MzI2NDA=" data-category="Announcements" data-category-id="DIC_kwDOEsP3AM4CSEqw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="https://hirrolot.github.io/giscus-theme.css" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script></div></body></html>